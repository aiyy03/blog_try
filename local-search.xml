<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库基本知识</title>
    <link href="/2023/07/16/c++%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/07/16/c++%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ol><li><p>数据库三大范式：第一，都是原子量不可分。第二，满足第一，然后非主属性，依赖主码（当出现复合主码的时候，不能依赖单一主码）。第三，满足第二，每个属性都跟主键有直接关系而不是间接关系。（非主键不能互相依赖，例如：主键学号，教室和老师直接互相依赖，所以不满足第三范式）</p></li><li><p>事务四大特性，原子性（要么一起成功要么一起失败），可持续性（不会回滚），隔离性（并发），一致性（和自然常识公理）</p></li><li><p>事务隔离性，可能存在问题：脏读，不可重复读（锁行），幻读（锁表）</p><p>隔离级别，读未提交，读已提交，可重复读(Mysql)，串行化。</p></li><li><p>数据库高并发解决方案：（1）web服务框架加入缓存（2）数据库拆分（3）添加服务器，主写，从读（4）分布式框架（5）加入数据库索引</p></li><li><p>共享锁，读的时候上，其他人也能上。排他锁，写的时候上，其他人不能进行任何操作。</p></li><li><p>悲观锁，就是认为一定会发生冲突数据开始读取的时候就把数据锁住。乐观锁，就是提交更行的时候检查是否有冲突。</p></li><li><p>mysql存储引擎：InnoDB和MylSam。</p><p>(1)MylSam: 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用 表级锁。</p><p>(2)InnoDB:支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表 行级锁。</p></li><li><p>事务怎么实现的，日志恢复，redo记录成功的保证持久性，undo记录事务处理前的数据，回滚保证原子性；并发控制。</p></li><li><p>数据库操作大多数是在外存上进行，文件I&#x2F;O操作会占用大量时间，红黑树为二叉树，深度更大，访问会更加耗时间。B+树，与B树对比，<strong>数据在叶子节点</strong>。适合范围查询。直接访问叶子节点就可以了。</p><p>（1）单一节点存储更多的元素，使得查询的IO次数更少。（2）所有查询都要查找到叶子节点，查询性能稳定。（3）所有叶子节点形成有序链表，便于范围查询。</p></li><li><p>通过一定规则，将key映射成地址，解决冲突方法：构造多个哈希函数，直到不冲突。建立公共溢出区，将冲突放在溢出区。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>database</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统基本知识点</title>
    <link href="/2023/05/07/c++%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/05/07/c++%E5%AD%A6%E4%B9%A0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.进程通信方式：有名管道，匿名管道，信号量，消息队列，socket，共享内存，信号。</p><p>2.死锁的条件：占有并等待，循环等待，非抢占，互斥</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>Operating System</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>linux基本知识</title>
    <link href="/2023/05/07/c++%E5%AD%A6%E4%B9%A0/linux/linux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/05/07/c++%E5%AD%A6%E4%B9%A0/linux/linux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ol><li><p>I&#x2F;O多路复用：单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。</p></li><li><p>epoll: linux实现高并发的技术，保证进程和线程间的切换高效。用到了I&#x2F;O多路复用技术，使得单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式基本知识点</title>
    <link href="/2023/05/07/c++%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2023/05/07/c++%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>1.单例模式：一般工具类，需要频繁使用，只需要让类只允许实例化一个对象。</p><p>2.简单工厂模式：背景首先，要在原来产品的基础上再开一个产品。满足这两个产品继承同一个抽象基类。</p><p>我不想直接用构造方法分别创建这两个产品的对象。用一个单独的类来做创造不同产品的实例，就有工厂的感觉。总共设计四个类。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>design pattern</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/03/c++%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/webRTC/"/>
    <url>/2023/05/03/c++%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/webRTC/</url>
    
    <content type="html"><![CDATA[<p>1.SDP:媒体信息，candidate:网络信息。ICE &#x3D; STUN + TURN,NAT实现地址转换（内网转到公网）然后STUN和TURN完成该功能。</p><p><strong>媒体协商（sdp）</strong></p><p>​彼此了解对方支持的媒体格式</p><p><strong>网络协商（candidate）</strong></p><p>​了解对方的网络情况</p><ol><li><p>获取外网IP地址映射</p></li><li><p>通信服务器交换网络信息</p></li></ol><p>实际情况是：我们电脑和电脑之间或大或小都是在某个局域网里面，需要NAT(网络地址转换)</p><p><strong>STUN</strong></p><p>​外网映射通信</p><p>STUN是一种网络协议，它允许NAT后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT为某一个本端口绑定的Internel（外网）端端口，外网就可以通过UDP通信。</p><p><strong>TURN</strong></p><p>​中继服务通信</p><p>如果上述外网映射通信不通的话，这时候需要公网作为一个中继，对来网的数据转发，这个转发的协议被定义为TURN服务网络（200kbps单向通信一对一带宽为良好的通信）</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>STL函数用法</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/STL/stl/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/STL/stl/</url>
    
    <content type="html"><![CDATA[<ol><li><p>sort()函数，默认的是对二维数组按照第一列的大小对每行的数组进行排序。所以可以加上cmp函数用按照任意列对数组进行排序</p></li><li><pre><code class="c++">set&lt;pair&lt;int, int&gt;&gt; booked; booked.lower_bound(&#123;end, 0&#125;)</code></pre><p>使用<code>lower_bound</code>函数(二分法 )找到第一个元素，其<code>pair&lt;int, int&gt;</code>类型的键大于或等于<code>&#123;end, 0&#125;</code>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++_class</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/c++%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%89%B9%E6%80%A7/c++_class/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/c++%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%89%B9%E6%80%A7/c++_class/</url>
    
    <content type="html"><![CDATA[<ol><li><p>拷贝构造函数</p></li><li><pre><code class="hljs">//在c中typedef struct Student&#123;int a;&#125;Stu;Stu stu1typedef struct Student&#123;int a;&#125;struct Student stu;//在c++中struct Student&#123;int a;&#125;;Student stu2;</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>syntax</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/STL/c++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/STL/c++%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>在树的深度优先遍历中（包括前序、中序、后序遍历），递归方法最为直观易懂，但考虑到效率，我们通常不推荐使用递归。</p><p>都是当前左子树，右子树。<strong>前序</strong>：根左右。<strong>后序</strong>：左右根。<strong>中序</strong>：左根右。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>STL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ffplay源码分析</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/ffplay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/ffplay%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<ol><li><p><img src="/../../../images%5Cimage-20230413155724148.png" alt="image-20230413155724148"></p><p>这是一个结构体初始化，“.”表示结构体成员的访问符号，其中URL开头的都是函数指针，这样虽然看似是声明了一个全局的结构体变量，依然能根据不同的参数（上下文）打开不同的音频文件。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>audio/video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>音视频播放器基础知识</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<ol><li><p>数据来源（本地，http）会抽象成一个buffer数据缓存接口，解复用的时候不用管数据类型，只有moov在前面才不是本地。</p></li><li><p>我们做播放器的时候都是选择以<strong>音频</strong>为基准去做同步。</p></li><li><p>IBP,I是当前帧，B是前后帧，P是预测帧。 GOP中gop cache-&gt;直播秒开（保证拉流端，一上来就能拉到I帧），如果拉到p帧，因为p帧要借鉴前面帧，会出现马赛克，这时候解码效果不好。</p><p>webrtc I帧间隔较大，有新加进来，可以请求发送。</p><p><img src="/../../../images%5Cimage-20230405133157870.png" alt="image-20230405133157870"></p></li><li><p>通过量化（DCT）可以使得较大数据变小，使码率变小，变化越大复原越难。</p></li><li><p>位深就是改变颜色通道的范围，原本0-256。</p></li><li><p>RTMP协议基于TCP来实现不支持H5，带宽问题。RTP和RTCP基于UDP来实现。</p></li><li><p>HLS协议基于HTTP短连接来实现，集合一段时间数据，生成ts切片文件，然后更新m3u8(HTTP Live Streaming直播的索引文件)，一般延迟会大于10s。HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</p></li><li><p>源代码中videocapturer基类可以设置想要的编码分辨率根据这个分辨率去采集，然后在子类中videoAdapter根据想要的编码分辨率计算出裁剪比例，将采集到不符合编码分辨率进行处理以满足。</p></li><li><p>webRTC默认使用VP8进行解码的，解除WebRTC对FFmpeg的依赖，接下来就是生成h264decoder涉及汇编优化，然后生成适配类，接着修改SDP协商与解码顺序把h264解码代码写在前面。</p><p>在default_args里面添加<br>  rtc_use_h264 &#x3D; true<br>  ffmpeg_branding &#x3D; “Chrome”</p></li><li><p>这个其实很简单，每当有人加入的时候就和已经在的用户（用哈希表）发送offer信令，然后等待建立peerconnection。</p></li><li><p>getDisplayMedia()这个api就能实现屏幕共享。</p></li><li><p>http必须客户端像服务端请求，不具备服务器推送的能力。</p></li><li><p>原本ip地址先通过证书配置成支持ssl安全通信的https地址（使得不再用本地地址host主机地址作为客户端访问），但是https不能访问ws，所以我们又通过nginx在中间进行代理用wss代理ws（添加了新的端口）</p></li><li><p>设置了一个abort当完成队列操作唤醒所有等待线程，是他们安全退出。通过abort支持阻塞唤醒。</p></li><li><p>使用<code>av_hwframe_map</code>代替<code>av_hwframe_transfer_data</code>的好处是可以减少内存拷贝操作，提高处理效率，特别是在需要处理大量视频数据时，可以更好地利用硬件加速的优势。同时，由于不需要拷贝数据，所以也可以减少内存的占用和分配次数。</p></li><li><p>音视频同步是指在播放过程中保持音频和视频的同步，让它们看起来像是在同时播放一样。在使用 FFmpeg 进行音视频播放的过程中，可以使用时钟（clock）来实现音视频同步。</p><p>具体来说，可以使用一个时钟来跟踪音频和视频的播放时间。音频播放需要采用硬件设备，因此可以通过查询设备的缓冲区来获取已经播放的音频样本数，然后将其转换为时间戳。对于视频播放，可以使用解码器返回的帧时间戳。这两个时间戳可以用来计算音视频的时间差。</p><p>在计算时间差之后，可以使用一个缓冲区来暂存音视频帧，直到它们的时间戳相等。当时间戳相等时，可以将它们合并并一起播放。</p><p>在实际应用中，还需要考虑音视频帧的延迟和丢帧的情况，以及如何应对这些情况对音视频同步的影响。</p></li><li><p>支持自适应窗口缩放这个如何实现的？</p><p>可以通过OpenGL中的glutReshapeFunc函数来注册窗口大小变化的回调函数，每当窗口大小变化时，该函数会被自动调用，可以在该函数中完成重新计算缩放比例等操作。</p></li><li><p>QOpenGLWidget是基于QWidget实现的OpenGL渲染窗口，它继承自QWidget，可以将其放在普通的QWidget容器中使用。</p></li><li><p>widget布局中添加了视频播放线程Qlist（实现视频的读取解码渲染工作），为什么实现Qlist是因为要同时渲染多个视频播放。</p></li><li><p>这段代码是用来初始化硬件解码器的。在函数中，首先获取指定编解码器codec所支持的硬件配置config，如果没有找到支持的硬件配置，则直接返回。如果找到支持的硬件配置，则判断是否是设备类型，并且是否是支持的硬件解码器。如果是，则打开指定类型的设备，并为其创建AVHWDeviceContext。然后，将硬件上下文绑定到解码器的上下文中，并设置像素格式get_format，以便让解码器知道使用哪种格式输出帧。最后，函数返回。步骤先通过ffmpeg硬解码接口获取硬解码config，本地判断是否满足，然后将对应类型填入硬解码上下文中，再将这个上下文绑定到解码器上下文中去，并指定输出像素格式。</p></li><li><p>将解码后的视频帧传输到openGL纹理中，glTexImage2D函数将YUV数据转换为RGB数据，并将其存储到纹理中。</p></li><li><p>弱网优化的策略包括如下：</p><ul><li>播放器Buffer</li><li>丢帧策略 (优先丢P帧，其次I帧，最后音频)</li><li>自适应码率算法</li><li>双向链路优化</li><li>音频FEC冗余算法(20%丢包率）</li></ul></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>audio/video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>c++_syntax</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/c++%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%89%B9%E6%80%A7/c++%E8%AF%AD%E6%B3%95/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/c++%E8%AF%AD%E6%B3%95%E5%8F%8A%E7%89%B9%E6%80%A7/c++%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<ol><li><p>数组 array.size()</p></li><li><p>&amp;有2种用法：1.取值2.引用，对于引用这个用法就是同一个地址取不同的变量名字（叫不同的名字），改变引用变量，原变量也随之改变。</p><p>*也有两种用途：1.声明2.间接引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;i = j;#引用<br><span class="hljs-type">int</span> i = &amp;j;#取值<br><span class="hljs-type">int</span> *i = &amp;j;#声明指针<br>*i = j;#间接引用，根据地址索引变量。<br></code></pre></td></tr></table></figure></li><li><p>函数传递变量三种，<strong>值传递，地址传递，引用传递</strong>。</p></li><li><p><strong>Extern关键字不能放在函数里面，要放在全局变量的位置</strong>。确定变量可以使用其他cpp文件声明的变量，extern可以置于变量或者函数前，以表示变量或者函数的定义在别的文件中，可以这么理解，<em>extern</em> 是用来在另一个文件中声明一个全局变量或函数。<strong>另外，extern也可用来进行链接指定。 有点类似python中的import可以自动寻找同一工程下面同名函数。</strong>一个变量被使用，要被定义(定义的同时声明了)，extern声明并不分配空间。 </p></li><li><p>指针和引用的区别：（1）指针不用初始化值，引用声明的时候需要指定绑定的变量。</p><p>右值引用： int &amp;&amp;a &#x3D; 1；目的是为了优化空间（减少复制次数，增加临时变量存活周期）</p><p>常量左值引用：const int &amp;a &#x3D; 1；（缺点只能是常量）</p></li><li><p>类型别名：auto不知道返回值类型，自动声明。</p></li><li><p>不要在头文件中使用using，std是一个标准的作用域。</p></li><li><p>在c++中一般就用string 去表示字符串，等价于char *，char *如果通过常量字符串定义是不可写的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-meta">#str放的是<span class="hljs-string">&quot;abc&quot;</span>的首位置，*str = <span class="hljs-string">&quot;a&quot;</span></span><br></code></pre></td></tr></table></figure></li><li><p>函数重载，<strong>相同的函数名</strong>。</p><p>(1)函数名称必须相同。 </p><p>(2)参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。</p><p>(3)函数的返回类型可以相同也可以不相同。 </p><p>(4)仅仅返回类型不同不足以成为函数的重载。</p></li><li><p>函数指针可以实现函数的回调，做的事情就是：在一个函数中，不改变其他执行语句，通过函数指针指向不同的函数，从而执行不同的函数。（当然也可以通过输入字符串匹配进行选择，感觉不够高效）</p><p><a href="https://blog.csdn.net/qq_41475825/article/details/105966064">(16条消息) 回调函数和普通调用函数_大龙哥。的博客-CSDN博客_回调函数和直接调用函数</a></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">int</span> (* p)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) = &amp; <span class="hljs-built_in">max</span>; <span class="hljs-comment">// &amp;可以省略</span><br></code></pre></td></tr></table></figure></li><li><p>对于指针来说一般指向的是栈（局部变量），通过new和malloc的方式能指向堆（<strong>这里开辟的空间不是指针变量，而是指针变量所指向的地方</strong>）。（我的理解可能是由于栈空间不够了，需要注意的是指向堆的指针，不要改变其指向的地址，不然开辟的堆无法释放，所以<strong>定义拷贝构造函数时要加const</strong>）</p></li><li><p>浅拷贝和深拷贝，（1）浅拷贝就是两个对象同时指向同一个位置  （2）深拷贝就是两个对象存储的值一致但是两个位置。</p></li><li><p>拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。<strong>一般类中会自带拷贝构造函数，但这是浅拷贝</strong>。如果类带有<strong>指针变量</strong>，并有<strong>动态内存分配</strong>，则它必须有一个拷贝构造函数。 暂时不理解条件为什么要加动态内存分配，我的理解是为了<strong>深拷贝</strong>，所以要自己重新写拷贝构造函数。</p><p>（成员变量存在指针的时候会出问题）反正都是传递的是const，不用改变为什么要引用传递？这是因为函数值传递的时候会用到复制的过程（即将当前变量赋值到临时变量调用调用拷贝构造，陷入递归调用）</p></li><li><p>拷贝赋值函数，就不是在构造的时候赋值。由于一开始存储数据的空间不一定一样，所以一开始要先删除   所指向的空间然后创建一个，再拷贝。注意在删除之前要进行<strong>自我赋值检测</strong>。</p></li><li><p>**弹性结构体，成员变量写成a[]**，其实就是个指针。但是这个指针所指向的空间会自动分配为结构体变量的下一个。</p><p>（1）空数组指长度为0的数组，仅可在类或者结构体中声明。</p><p>定义空数组的好处有：</p><ol><li><p>不占用空间，如果是指针的话还需要4字节空间，而空数组不占用任何空间</p></li><li><p>无需初始化，数组名直接就是所在的偏移，如果是指针则需要给指针赋值</p><p>通常用来申请buff空间的写法是：</p><p>malloc(sizeof(strTest) + bufflen);</p><p>这样即可一次给结构体和缓冲区分配内存，减少使用和维护成本.。</p></li></ol></li><li><p>string和string.h是两个东西，一个c++一个是c，cstring对应string.h。</p></li><li><p>句柄handle，是一个void类型指针貌似。（待更新）</p></li><li><p>智能指针，指向动态空间，可以自动释放空间。（待更新）（需要特殊方式定义）RAII的思想。一共有三种：Unique（一个指针对应一个对象），shared（多个指针对应一个对象，最后一个指针超出 作用域）（线程不安全：引用计数），weak（避免循环引用）</p></li><li><p>（1）函数重载：函数名相同，变量列表必须不相同。</p><p>（2）函数重写：（函数名和函数参数列表必须完全一样）<strong>父类虚函数</strong>，不一定在子类重写，<strong>重写之后调用父类方法依旧是子类方法</strong>。<strong>父类纯虚函数</strong>,子类一定要重写。在C++中子类对象调用父类函数可通过<strong>域操作符(::)</strong></p><p>（3）函数重定义：函数名相同，变量列表可以不相同，子类对象时候调子类方法，父类对象时调父类方法。</p></li><li><p>模板类的实现和定义应该尽量都放在头文件中实现。</p></li><li><p>类的组合在该类中用其他类的对象。</p></li><li><p>函数也有地址，函数名代表函数地址。对于 fun 和 &amp;fun 应该这样理解：</p><p><strong>他们两值完全一样。</strong></p><p>(1). fun 是函数的首地址，它的类型是 void ()<br>(2). &amp;fun 表示一个指向函数 fun 这个对象的地址， 它的类型是 void (*)()<br>因此 fun 和 &amp;fun 所代表的地址值是一样的，但类型不一样。fun 是一个函数<br><strong>&amp;fun 表达式的值是一个指针！</strong></p></li><li><p>c++提供了关键字<strong>explicit</strong>,阻止了隐式构造。</p></li><li><p>const成员函数，该函数可以被 const 对象调用，并且不能修改类中的任何成员变量。</p><p>operator有2种用法，第一个是重载操作运算符，一种是隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>NULL在c++种宏定义为0，函数重载时难以判断到底是int 0还是 (void*) 0.</p></li><li><p>RAII，全称为Resource Acquisition Is Initialization，汉语是“资源获取即初始化”。就是资源获取的时候将其封装在某类的object中。利用”栈资源会在相应object的生命周期结束时自动销毁”来自动释放资源，即，构造函数创建时初始化获取资源，并将资源释放写在析构函数中。所以这个RAII其实就是和智能指针的实现是类似的。（核心思想：<strong>将资源和类对象绑定，用构造申请，析构释放</strong>）</p><p>（1） <strong><code>lock_guard</code></strong> 和**<code>unique_lock</code>**都是这一思想，在创造对象的时候lock()，对象销毁的时候unlock()。给互斥量上锁，以为着只有当前线程能进对资源进行操作。</p><p>（2）**<code>unique_lock</code>**还能和条件变量一起使用，实现线程同步通信，同时也能手动解锁。</p></li><li><p>条件变量（<strong>为了实现线程同步通信</strong>）的几个关键点：</p><p>（1）wait()函数的内部实现是：先释放了互斥量的锁，然后阻塞（已经unlock）以等待条件为真；</p><p>（2）notify系列函数需在unlock之后再被调用；（不一定）</p><p>（3）套路是：  </p><p>​    a. A线程拿住锁，然后wait,此时已经释放锁，只是阻塞了在等待条件为真；<br>            b. B线程拿住锁，做一些业务处理，然后令条件为真，释放锁，再调用notify函数；<br>​    c. A线程被唤醒，接着运行。</p></li><li><p>位运算：<img src="/../../../images/image-20230410155416133.png" alt="image-20230410155416133"></p></li><li><p><strong>尽量指针传递的时候用引用传递</strong>。如果说只是改变指针所指向地方的值，传递指针是没有问题的。然而有可能接收的指针是空指针，难免要指向其他地方。</p></li><li><p>注意，数组名虽然是指针，但是不能如下操作，因为该函数返回类型为void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ret.<span class="hljs-built_in">push_back</span>(temp_vec1.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()-&gt;val));<br></code></pre></td></tr></table></figure></li><li><p>需要注意的是数组名是指针，而vector是对象。</p></li><li><p>静态函数不能访问非静态成员变量。<strong>因为静态函数中没有this指针</strong>。</p></li><li><p>sizeof是运算符。</p></li><li><p>抽象基类，必须有一个纯虚函数。不能实例化对象，必须被子类重写。</p></li><li><p>C++通过虚函数表，<strong>实现了虚函数与对象（即父类指针指向哪个子类，就用哪个子类的虚函数表中对应的虚函数）的动态绑定</strong>。每个对象会初始化的过程中，定义一个虚函数表指针，指向虚函数表。虚函数表中含有该类所用有的虚函数的（虚函数指针）。（需要注意通常情况，子类重写了父类虚函数，没有显式添加 <code>virtual</code> 关键字，也会自动成为虚函数） 实际上，基类指针指向子类指针，会发生向上转型，这个子类对象会，转为基类指针。</p></li><li><p>数组名为什么从0开始，因为a[i] &#x3D; base + i*sizeof()，可以减少一次减一操作。</p></li><li><p>c++内存分区：代码区，全局&#x2F;静态存储区，栈区，堆区和常量区。</p></li><li><p>语法不同：malloc&#x2F;free是一个C语言的函数，而new&#x2F;delete是C++的运算符。</p><p>分配内存的方式不同：malloc只分配内存，而new会分配内存并且调用对象的构造函数来初始化对象。</p><p>返回值不同：malloc返回一个 void 指针，需要自己强制类型转换，而new返回一个指向对象类型的指针。<br>malloc 需要传入需要分配的大小，而 new 编译器会自动计算所构造对象的大小</p></li><li><p>public继承：当子类以public继承时，其父类中的访问权限全都不变的继承到子类；</p><p>protected继承：当子类以protected继承时，其父类中的public被继承为protected；</p><p>private继承：当子类以private继承时，其父类中的public和protected都被继承为private。</p></li><li><p>移动语义的用处：定义一个移动构造函数，如果需要拷贝右值，则为了避免深拷贝，开辟多余空间，只需要把右值空间给予需要拷贝的变量就行（右值往往只需要浅拷贝）。注意：<strong>需要注意的是，拷贝构造函数必须要用const &amp;常量引用的原因就是为了保证能深拷贝右值，而不只是左值</strong>。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>syntax</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络编程</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>数据流：tcp</p><p>数据报：udp</p><p>服务端搭建：（服务器端口号就是他所监听的端口号）</p><p>（1）<strong>网络通信初始化</strong> WSAStartup();</p><p>（2）<strong>创建服务端套接字</strong> socket(套接字类型，数据流，协议);</p><p>（3）<strong>设置套接字类型</strong> 端口可复用（可省略） setsocket();</p><p>（4）<strong>配置服务器端的网络地址</strong>  struct sockaddr_in server_addr;这个变量包括服务器地址和端口号。</p><p>（5）<strong>将套接字和server_addr进行绑定</strong> bind();</p><p>（6）<strong>动态给server_addr分配端口号</strong>，端口号初始化如果为0的话，进行getsockname()动态分配。</p><p>（7）<strong>创建监听队列</strong>，为接受客户端地址做准备。</p><p>客户端请求：</p><p>（1）根据服务端套接字和客户端地址，<strong>为客户端分配套接字</strong></p><ol><li><p>三次握手：后面两次是为了确认，在服务端确认客户端能接受到服务端发送的数据。</p></li><li><p>四次挥手：第一次客户端向服务器，通过FIN报文告诉他客户端数据传输完了，你服务器传完了就可以关了。进入FIN-WAIT-1状态。第二次服务器给客户端发送，告诉他我知道了，但是等我我发送完，客户端进入2状态，服务器进入close_wait状态。第三次，服务器发完了所有告诉客户端，你可以关闭了，等着client最后的ACK信息，如果说接到的信息不对，会持续给客户端发送，所以进入的是last_ack状态。第四次，客户端发向服务端，进入2msl等待状态，防止第三次信息没法送出去，就提前终止。</p></li><li><p>TCP和udp区别：（1）面向连接（2）一个数据流一个数据报（3）tcp提供流量控制和拥塞控制 （4）udp支持一对多</p></li><li><p>浏览器输入URL后执行的全部过程。</p><p>（1）首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；<br>（2）然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；<br>（3）接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）<br>（4）服务器对客户端发来的http请求进行处理，并返回响应；<br>（5）客户端接收到http响应，将结果渲染展示给用户。</p></li><li><p>TCP怎么保证可靠性的（校序重流拥）</p><p>（1）校验和<br>发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p><p>（2）确认应答+序列号<br>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p><p>（3）超时重传<br>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p><p>（4）流量控制<br>TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>接收方有即时窗口（滑动窗口），随ACK报文发送</p><p>（5）拥塞控制（慢启动，拥塞避免，快速重传和快速恢复）<br>当网络拥塞时，减少数据的发送。<br>发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p></li><li><p>http&#x2F;1.0和http&#x2F;1.1的区别</p><p>1.1默认常连接，不用重新建立TCP连接，减少了反复建立TCP连接的的消耗和延迟.</p></li><li><p>http请求方法有哪些，get和post的区别。</p><p>http的请求包括get,post,put,delete。四种方法（只有post不是操作幂等性的）。</p><p>（1）get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源<br>（2）get可以保存为书签，可以用缓存来优化，而post不可以<br>（3）get把请求附在url上，而post把参数附在http包的包体中<br>（4）浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等<br>（5）post可以传输二进制编码的信息，get的参数一般只支持ASCII</p></li><li><p>cookie和session的区别？</p><p>（1）作用范围不同，cookie保存在客户端，session保存在服务器端</p><p>（2）cookie一般作用时间长一点，类比自动登录功能。</p><p>（3）cookie由于在客户端，隐私保护没有那么好，容易被窃取。</p><p>（4）cookie存储大小一般小一点。</p></li><li><p>redis：不是关系型数据库，支持更复杂的数据结构。 key-value 模型。单线程，纯内存操作，避免了上下文切换的开销，非阻塞的多路复用I&#x2F;O机制。</p></li></ol><p>​</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>net</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ijkplayer源码分析</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/ijkplayer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/ijkplayer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>1.貌似把sdl模块给重写了。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>audio/video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>音视频常见函数</title>
    <link href="/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/"/>
    <url>/2023/04/17/c++%E5%AD%A6%E4%B9%A0/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>1.</strong><code>avformat_open_input</code> 是 FFmpeg 中的一个函数，用于打开一个输入文件并创建一个 <code>AVFormatContext</code> 结构体，该结构体包含了输入文件的格式和元数据等信息，可以被后续的解码操作所使用。</p><p>函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">avformat_open_input</span><span class="hljs-params">(AVFormatContext **ps, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url, AVInputFormat *fmt, AVDictionary **options)</span></span>;<br></code></pre></td></tr></table></figure><p>函数参数说明：</p><ul><li><code>ps</code>: 指向指针的指针，用于存储创建的 <code>AVFormatContext</code> 结构体的地址。</li><li><code>url</code>: 输入文件的 URL。</li><li><code>fmt</code>: 输入文件的格式，如果为 NULL，则自动检测输入文件的格式。</li><li><code>options</code>: 一些额外的选项，可以为 NULL。</li></ul><p>该函数返回值为 0 表示成功，其他值表示失败。如果返回值为非零，可以使用 <code>av_strerror</code> 函数将错误码转换为错误信息。调用该函数成功后，应该在结束使用 <code>AVFormatContext</code> 结构体后，调用 <code>avformat_close_input</code> 函数来释放资源。</p><p><strong>2.</strong><code>avformat_find_stream_info</code>是FFmpeg多媒体框架中的一个函数，用于读取和解码给定输入文件中的多媒体数据，并初始化文件中包含的每个流的相关结构。</p><p><strong>3.</strong><code>av_dump_format</code>是FFmpeg多媒体框架中的一个函数，用于将给定的AVFormatContext中的多媒体信息打印到标准输出。</p><p><strong>4.</strong><code>av_find_best_stream</code>是FFmpeg多媒体框架中的一个函数，用于在输入文件中查找最佳的流以进行解码。例如：指定解码视频流，则找到最适合的视频流进行解码。</p><p><strong>5.</strong><code>avcodec_parameters_to_context</code> 是 FFmpeg 中的一个函数，用于将音视频编码参数（<code>AVCodecParameters</code>）拷贝到编码器上下文（<code>AVCodecContext</code>）中。</p><p>**6.**avcodec_open2()中的AVCodecContext，已经通过avcodec_parameters_to_context()复制了数据，为什么还需要进行初始化?</p><p>​<code>avcodec_open2()</code>函数的作用是打开给定的解码器，初始化它的AVCodecContext结构体，以便后续可以解码音频或视频数据。虽然在调用<code>avcodec_parameters_to_context()</code>函数之后，AVCodecContext结构体中已经有了一些数据，但是这些数据仅仅是从AVCodecParameters结构体中复制过来的，还不足以满足解码器的初始化要求。例如，一些必要的结构体指针可能还未初始化，某些编解码器需要特定的选项等等。</p><p>​因此，在调用<code>   avcodec_parameters_to_context()</code>函数之后，还需要通过<code>avcodec_open2()</code>函数对AVCodecContext进行初始化，以便解码器能够正常工作。在该函数内部，还会检查一些参数的合法性，并进行解码器所需的一些结构体初始化。如果不调用<code>avcodec_open2()</code>函数，AVCodecContext中的结构体指针将为空，解码器无法工作。</p><p><strong>7</strong>.avcodec_receive_frame(codec_ctx_, frame);这段代码中，对数据包解码了下次运行还会对原来数据包解码吗?</p><p>​不会。当调用<code>avcodec_receive_frame()</code>函数成功获取到一个完整的解码帧时，该解码帧所对应的数据包已经被解码完毕并且从解码器中移除了。因此，下次调用<code>avcodec_receive_frame()</code>时，解码器将会解码下一个数据包，而不是之前已经解码过的数据包。如果解码器缓冲区中没有任何数据包等待解码，<code>avcodec_receive_frame()</code>函数会返回<code>AVERROR(EAGAIN)</code>，告诉你需要等待更多数据包到达解码器缓冲区。</p><p>**8.**这是一个函数声明的前缀，用于指定函数的可见性和调用约定。</p><p>在SDL库中，函数声明通常使用以下格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">extern</span> DECLSPEC return_type SDLCALL <span class="hljs-title">function_name</span><span class="hljs-params">(arguments)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，<code>DECLSPEC</code>和<code>SDLCALL</code>是前缀宏，它们分别指定函数的可见性和调用约定。具体来说：</p><ul><li><code>DECLSPEC</code>指定函数的可见性，这取决于平台和编译器的不同。在Windows平台下，<code>DECLSPEC</code>被定义为<code>__declspec(dllexport)</code>或<code>__declspec(dllimport)</code>，用于指定函数是在DLL中导出还是导入。在其他平台下，<code>DECLSPEC</code>可能为空。</li><li><code>SDLCALL</code>指定函数的调用约定，即函数在被调用时应该如何处理参数、返回值和堆栈等。不同平台和编译器可能使用不同的函数调用约定，因此需要使用不同的<code>SDLCALL</code>宏定义来适配。在SDL库中，<code>SDLCALL</code>通常被定义为<code>__cdecl</code>或<code>_System</code>，具体取决于平台和编译器的不同。</li></ul><p>这些前缀的作用是确保函数在不同平台和编译器下都能正确地编译和链接，并且在被调用时可以正确地处理参数和返回值，避免出现不可预期的错误。</p><p>**9.**wanted_spec.userdata &#x3D; this;</p><p>在代码<code>wanted_spec.userdata = this;</code>中，<code>this</code>指针代表当前对象的指针，这行代码的作用就是将当前对象的指针赋值给<code>wanted_spec</code>结构体中的<code>userdata</code>字段，以便在音频回调函数中可以使用该指针访问和操作当前对象。<strong>相当于该结构体中的成员变量，存储了一个指向当前对象的指针。</strong></p><p>**10.**abort的作用</p><p>​根据您提供的代码，这是一个模板类 <code>my_Queue</code>，实现了一个基本的线程安全队列。其中 <code>Abort()</code> 方法设置了一个标志位 <code>abort_</code>，并通过条件变量 <code>cond_</code> 唤醒所有等待的线程，以通知它们队列已经无效。 <code>Push()</code> 方法向队列中添加元素，如果队列已经无效，则返回错误码 <code>-1</code>，否则加锁，将元素压入队列，并通过条件变量 <code>cond_</code> 唤醒一个等待的线程。 <code>Pop()</code> 方法从队列中弹出一个元素，如果队列已经无效，则返回错误码 <code>-1</code>，如果队列为空，则返回错误码 <code>-2</code>，否则等待元素可用，并在超时时唤醒线程。 <code>Front()</code> 方法和 <code>Pop()</code> 方法类似，但不会从队列中弹出元素，而是直接返回队列头部元素的值。<code>Size()</code> 方法返回队列当前的元素数量。</p><p>​此代码的作用是提供一个线程安全的队列，以便多线程环境下的数据交换和共享。通过使用互斥锁和条件变量来保证队列的线程安全性。同时，通过 <code>Abort()</code> 方法，可以随时中断队列的操作，以便安全退出线程。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
      <category>audio/video</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/23/hello-world/"/>
    <url>/2023/03/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
